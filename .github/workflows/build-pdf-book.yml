name: Build PDF Book

on:
  workflow_dispatch:
  push:
    branches: [master]

jobs:
  generate-pdf:
    permissions:
      contents: write
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Gather Markdown files from A1 vault (ordered)
        run: |
          # Prefer explicit pdf-order.txt in A1/ to control chapter order; fallback to find
          rm -f md-list.txt md-list-filtered.txt combined.md || true
          if [ -f "A1/pdf-order.txt" ]; then
            echo "Using A1/pdf-order.txt for PDF order"
            # strip empty lines and comments
            sed -e 's/\r$//' A1/pdf-order.txt | sed '/^\s*$/d' > md-list.txt
          elif [ -d "A1" ]; then
            echo "A1/pdf-order.txt not found; discovering .md files under A1/"
            find A1 -path 'A1/tmp' -prune -o -path 'A1/.obsidian' -prune -o -name '*.md' -print | sort > md-list.txt
          else
            echo "A1 directory not found; exiting with empty list" > md-list.txt
          fi
          # Remove any entries that accidentally point into .github
          grep -v '^.*/.github/' md-list.txt > md-list-filtered.txt || cp md-list.txt md-list-filtered.txt
          # Combine into one file in the explicit order. Remove YAML frontmatter and any audio/media references
          while IFS= read -r f; do
            if [ -f "$f" ]; then
              echo "\n\n<!-- Source: $f -->\n\n" >> combined.md
              # strip leading YAML frontmatter if present, then remove audio/media lines
              python -c '
                import sys
                import re
                from pathlib import Path

                path = Path(sys.argv[1])
                text = path.read_text(encoding="utf-8")

                if text.startswith("---"):
                    text = re.sub(r"^---\r?\n.*?\r?\n---\r?\n?", "", text, count=1, flags=re.S)

                pattern = re.compile(r"(audio|\.mp3|\.mp4|\.wav|\.ogg|\.m4a)", re.IGNORECASE)

                for line in text.splitlines():
                    if pattern.search(line):
                        continue
                    print(line)
              ' "$f" >> combined.md
            else
              echo "Warning: listed file '$f' not found" >&2
            fi
          done < md-list-filtered.txt

      - name: Install Pandoc and dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y pandoc texlive-xetex texlive-fonts-recommended fonts-dejavu-core

      - name: Set version info
        run: |
          VERSION=$(python - <<'PY'
            import pathlib
            import re

            default = "0.0.0"
            path = pathlib.Path("manifest.yml")
            if not path.exists():
                print(default)
            else:
                text = path.read_text(encoding="utf-8")
                match = re.search(r"^version:\s*(.+)$", text, re.MULTILINE)
                value = match.group(1).strip() if match else default
                value = value.strip('"').strip("'")  # remove optional quotes
                print(value)
          PY
          )
          if [ -z "$VERSION" ]; then VERSION="0.0.0"; fi
          echo "BOOK_VERSION=$VERSION" >> $GITHUB_ENV
          echo "BOOK_TAG=v$(date +'%Y-%m-%d')" >> $GITHUB_ENV
          echo "BOOK_NAME=holandes-curso-A1-${VERSION}.pdf" >> $GITHUB_ENV

      - name: Generate PDF with versioned name
        run: |
          pandoc combined.md -o "$BOOK_NAME" \
            --pdf-engine=xelatex \
            -V mainfont="DejaVu Sans" \
            --toc --number-sections

      - name: Upload PDF as artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BOOK_NAME }}
          path: ${{ env.BOOK_NAME }}

      - name: Create GitHub Release with PDF
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.BOOK_TAG }}
          name: "Holandes Curso A1 - v${{ env.BOOK_VERSION }} (${{ env.BOOK_TAG }})"
          body: "Automated PDF export of the Holandes vault (A1 course)."
          files: "${{ env.BOOK_NAME }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
